#include <vector>
#include <string>
#include <map>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <algorithm>
#include <numeric>
#include <cmath>
#include <random>
#include <stdio.h>
#include <stdlib.h>

using namespace std;


void help() {
	cout << "\nArgument help:\n";
			"1st argument:\n";
    		"            filename of the sequences ['.fasta' or '.paml'] format.\n";
			"            or\n";
   			"            [-random INT] : generate a random distance matrix of size INT x INT and create a Newick format tree with INT leaf nodes\n\n";
			"Additional arguments: \n";
			"Methods for calculating the distance matrix based on kmer profiles of sequences:  \n\n";
			"            [-m] : mahalanobis; \n";
			"            [-c] : cosine. \n";
			"            (default: fractional k-mer count)\n\n";
			"kmer-length (default 8): \n";
			"            [-k INT]:\n\n";
			"Number of replicates to parse in .paml files of synthetic sequences (default 1): \n";
			"            [-replicates INT]\n";
			"            Outputs INT Newick trees each based on a different set of replicate sequences.\n\n";
			"Verbose:    [-v]\n";
}

///////////////
/// Structs ///

// Define the nodes of the tree
struct node {
	int id, parent, level, child1, child2;
	float child1_distance, child2_distance; // distances
	bool isleaf;
	string name, subtree; 
    // 'subtree' stores the subtree of a node in newick format
};

// Sequences and their names
struct sequence {
	vector<string> seq;
	vector<string> name;
};

/* Distance matrix
Stores the distance values for each sequence as well, their ids and their total sum,
in order to avoid having to iterate through the whole vector to get its sum in every iteration of Neighbor-Joining*/
struct dmatrix_row {
	vector<float> distances;
	float sum;
	int id;
};

// Tree class
// To store subtrees of each node in newick format
// Nodes are joined using N-J
class Tree {
public:
	vector<node> tree; 		   // Stores the nodes
	string newick;
	Tree(sequence); 		   // Constructor from sequences
    Tree(vector<dmatrix_row>); // Constructor from Distance Matrix
	void joinNodes(int, int, float, float);
};

/////////////////////////////////
// Read FASTA file, get strings of DNA sequences, store them in a 'sequence' struct
// which contains the names and nucleotide sequences
sequence read_fasta(string filename) {
	sequence sequence_list;
	ifstream input(filename.c_str());
	
	if (!input.good()) {
		cerr << "Error opening '" << filename << endl;
	}
	else if (input.good()) {
		cout << "Reading '" << filename << "'...";
	}
	string line, content, name;
	while (getline(input, line).good()) {
		if (line.length() <= 1) {
			if (!content.empty()) {
				sequence_list.seq.push_back(content);
				sequence_list.name.push_back(name);
			}
			content.clear();
			name.clear();
		}
		if (line[0] == '>') {
			line = line.substr(1, line.length() -1); // Remove '>'
			name = line;
		}
		else {
			content += line;
		}
	}
	input.close();
	cout << "  Number of sequences: " << sequence_list.seq.size() << endl;;

	return sequence_list;
}

// Read synthetic sequence data (PAML Format), generated by Evolver module of PAML Software
// Stores replicates in a vector of sequence structs
// Reads up to the number of replicates (n_replicates) specified.
vector<sequence> read_paml(string filename, int n_replicates) {

	vector<sequence> sequence_list(n_replicates);
	ifstream input;
	input.open(filename);
	int sequence_number = 0; // Current sequence
	int batch = 0; 		     // Indicator for current replicate batch
    int n_seq;				 // Number of sequences
	string line, name;

	if (!input.good()) {
		cerr << "Error opening '" << filename << endl;
	}
	else if (input.good()) {
		cout << "\nReading '" << filename << "'...";
	}

	// Read all the synthetic sequences up to the number of replicates (n_replicates)
	while (getline(input, line).good() & (batch < n_replicates)) {
        if (!line.empty() && line.size() > 2 && line.size() < 100) {
            n_seq = stoi(line.substr(0,7));
        }

		if (!line.empty() && line[0] != ' ' && line.length() > 100) {
            name = line.substr(0, 10);
			line.erase(line.begin(), line.begin() + 30);
			name.erase(remove_if(name.begin(), name.end(), static_cast<int(*)(int)>(&std::isspace)),name.end());
			line.erase(remove_if(line.begin(), line.end(), static_cast<int(*)(int)>(&std::isspace)),line.end()); // Remove whitespace
			sequence_list[batch].seq.push_back(line);
			sequence_list[batch].name.push_back(name);
			sequence_number += 1;
			
			if (sequence_number >= n_seq) {
				batch += 1;
				sequence_number = 0;
			}

		}
	}

    cout << "  Number of unique sequences: " << n_seq << endl;
	input.close();
	cout << "LENGTH: " << sequence_list[0].seq.size() << "   " << sequence_list[0].seq[0].length();

	return sequence_list;
}

///////////////////////////////////////////////////////////////////
// Read the sequences and count kmers of length k (arg kmer_length)
// Counts only kmers containing ACGT, ignoring all the non-standard characters

vector<vector<float>> count_kmer_frequencies(sequence& sequences, int& kmer_length) {
	cout << "Reading sequences, counting K-mers of length: " << kmer_length << "..." << endl;
	map<string, int> unique_kmers; // kmer mapping
	vector<vector<float>> kmer_frequencies(sequences.seq.size());
	int index, flag;
	int unique_counter = 0; // Counter for total number of unique kmers found

	// Read through sequences
	for (int i = 0; i < sequences.seq.size(); i++) { 
		for (int j = 0; j <= sequences.seq[i].length() - kmer_length; j++) { // for each k-mer in the sequence
			flag = 0;

			string kmer = sequences.seq[i].substr(j, kmer_length);
			for (int s = 0; s < kmer_length; s++) {
				if (kmer[s] != 'A' && kmer[s] != 'C' && kmer[s] != 'G' && kmer[s] != 'T') {
					flag = 1; // Check if kmer contains only {A, C, G, T}
					break;
				}
			} 

			if (!unique_kmers[kmer] && flag != 1) {					// Check if the kmer is already in the mapping
				unique_kmers[kmer] = unique_counter;				// assign the new kmer an index
				for (int k = 0; k < kmer_frequencies.size(); k++) { // 
					kmer_frequencies[k].push_back(0);               // Extend the kmer frequency vectors of all sequences             
				}
				kmer_frequencies[i][unique_counter] += 1;  
				unique_counter += 1;
			}

			else { // If the kmer already exists, get the integer that it is mapped to and use it as index
				index = unique_kmers[kmer];
				kmer_frequencies[i][index] += 1;
			}

		}
	}
	cout << "Different K-mers found: " << kmer_frequencies[0].size();

	return kmer_frequencies;
}


///////////////////
//  Get the distance matrix based on k-mer frequency profiles
// 'method' string defines the distance measure - [cosine / mahalanobis / fractional]

vector<dmatrix_row> distance_matrix(vector<vector<float>>& frequencies, sequence& sequences, int kmer_length, string method) {
	int n_sequences =  frequencies.size();
    float kmer_profile_length = frequencies[0].size();
	vector<dmatrix_row> D (n_sequences);
        
    if (method == "cosine") { 
        cout << "\nMeasuring cosine distance between sequence kmer profiles" << endl;
        // Cosine similarity
        for (int i = 0; i < n_sequences; i++) {
            // Create a new row of Distance matrix
            dmatrix_row row;
            row.distances.resize(n_sequences);
            for (int j = 0; j < n_sequences; j++) {
                float dot_product = 0.0, denom_a = 0.0, denom_b = 0.0;
                if (i != j) {
                    for (int k = 0; k < kmer_profile_length; k++) {
                        dot_product += frequencies[i][k] * frequencies[j][k];
                        denom_a += frequencies[i][k] * frequencies[i][k];
                        denom_b += frequencies[j][k] * frequencies[j][k];
                    }
                    float similarity = dot_product / (sqrt(denom_a) * sqrt(denom_b));
                    row.distances[j] = 1 - (similarity);
                }
                else {
                    row.distances[j] = 0;
                }
            }
            row.sum = 0;
            row.id = i;
            D[i] = row;
        }
    }

    // Mahalanobis distance
    else if (method == "mahalanobis") {
        cout << "\nMeasuring mahalanobis distance between sequence kmer profiles" << endl;
        vector<float> kmer_std;
        kmer_std.resize(kmer_profile_length);

        // Calculate standard deviations for each unique kmer
        for (int k = 0; k < kmer_profile_length; k++) {
            float sum, variance = 0.0;
            for (int j = 0; j < n_sequences; j++) { //Mean
                sum += frequencies[j][k];
            }
            float mean = sum / kmer_profile_length;

            for (int j = 0; j < n_sequences; j++) { // Variance
                variance += pow((frequencies[j][k] - mean), 2);
            }
            kmer_std[k] = sqrt(variance);
        }
        
        // Calculate distances using the mahalanobis measure (euclidean distance normalized by standard deviation)
        for (int i = 0; i < n_sequences; i++) {
            // Create a new row of Distance matrix
            dmatrix_row row;
            row.distances.resize(n_sequences);
            for (int j = 0; j < n_sequences; j++) {
                float sum = 0;
                if (i != j) {
                    for (int k = 0; k < kmer_profile_length; k++) {
                        sum += pow((frequencies[i][k] / kmer_std[k] - frequencies[j][k] / kmer_std[k]), 2);
                    }
                    row.distances[j] = sum / 100;
                }
                else {
                    row.distances[j] = 0;
                }
            }
            row.sum = 0;
            row.id = i;
            D[i] = row;
        }
    }

    // Fractional common kmer count
    else if (method == "fractional") {
        cout << "\nMeasuring fractional k-mer count distance between sequence kmer profiles" << endl;
        for (int i = 0; i < n_sequences; i++) {
            // Create a new row of Distance matrix
            dmatrix_row row;
            row.distances.resize(n_sequences);
            for (int j = 0; j < n_sequences; j++) {
                if (i != j) {
                    float sum = 0;
                    for (int k = 0; k < kmer_profile_length; k++) {
                        float denominator = min(sequences.seq[i].size(), sequences.seq[j].size()) - kmer_length + 1;
                        sum += min(frequencies[i][k], frequencies[j][k]) / denominator;
                    }
                    row.distances[j] = - log(0.1 + sum);
                }
                else {
                    row.distances[j] = 0;
                }
            }
            row.sum = 0;
            row.id = i;
            D[i] = row;
        }
    }
    else {
        cout << "\nInvalid distance measure.";
        return D;
    }
    // Sum rows
    for (int i = 0; i < n_sequences; i++) {
		for (int j = 0; j < n_sequences; j++) {
            D[i].sum += D[i].distances[j]; // Calculate the sum of the row
		}
	}
    return D;
}


//////////////////////////////
// Neighbor Joining algorithm
// Recursively creates a tree with weighted branch lengths from a distance matrix

void neighbor_joining(vector<dmatrix_row>& D, Tree& tree, bool verbose) {
	int size = D.size();
	vector<vector<float>> Q_matrix(size, vector<float>(size));
	int min_i, min_j = 0; // indices of smallest element
	
	// Calculate Q-matrix and find the indices of sequence pair i,j with the lowest score
	// which correspond to the two closest sequences
	float smallest_element = INFINITY;
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
			if (i == j) {
				Q_matrix[i][j] = 0;
			}
			else { // Calculate the i,j th element of Q matrix and keep track of the smallest value
				Q_matrix[i][j] = D[i].distances[j] - D[i].sum / (size - 1) - D[j].sum / (size - 1);
				if (Q_matrix[i][j] < smallest_element) {
					smallest_element = Q_matrix[i][j];
					min_i = i;
					min_j = j;
				}
			}
		}
	}

	// Update tree and calculate branch lengths of the two closest sequences that are being joined
	float branch_length1 = abs((D[min_i].distances[min_j] + (D[min_i].sum - D[min_j].sum) / (size - 1)) / 2);
	float branch_length2 = abs((D[min_i].distances[min_j] + (D[min_j].sum - D[min_i].sum) / (size - 1)) / 2);
    if (verbose) {
        cout << "Joined nodes: " << D[min_i].id << " and " << D[min_j].id << " with distances : " << branch_length1 << " and " << branch_length2 << endl;
    }
	
	// Update the tree
	tree.joinNodes(D[min_i].id, D[min_j].id, branch_length1, branch_length2);
	
	// Updating the distance matrix
	// Create the newly joined node in the distance matrix, delete the joined ones
	dmatrix_row new_node;
	int s1 = max(min_i, min_j);  // Find the larger index for correct removal from the matrix (larger index gets removed first)
	int s2 = min(min_i, min_j);
	float sum_of_distances = 0;
	for (int i = 0; i < size; i++) {              
		float dist1 = D[i].distances[s1];
		float dist2 = D[i].distances[s2];
		float new_distances = (dist1 + dist2 - D[s1].distances[s2])/2;  // Distance to new node

		if (i != min_i && i != min_j) {
			new_node.distances.push_back(new_distances);
			sum_of_distances += new_distances;
		}

		D[i].sum += new_distances - dist1 - dist2;          // Update sums of distances of all other sequences
 		D[i].distances.erase(D[i].distances.begin() + s1);  // Erase column 1
		D[i].distances.erase(D[i].distances.begin() + s2);  //              2
		D[i].distances.push_back(new_distances);            // Insert new column
	}

	new_node.distances.push_back(0); // Distance to self

	new_node.sum = sum_of_distances;
	new_node.id = tree.tree.size() - 1;
	D.erase(D.begin() + s1);  // Erase row 1
	D.erase(D.begin() + s2);  //           2
	D.push_back(new_node);    // Insert new row
				

	if (size > 2) {           // Recursively repeat with a new distance matrix until all nodes are joined except one
		neighbor_joining(D, tree, verbose);
	}
}

///////////////////////
// Tree Class functions
Tree::Tree(sequence sequences) {   // Tree constructor from sequences
	cout << "Creating tree..." << endl;
	newick = "";
	int size = sequences.seq.size();
	for (int i = 0; i < size; i++) {
		node new_node;
		new_node.id = i;
		new_node.isleaf = true;
		new_node.name = sequences.name[i];
		tree.push_back(new_node);
	}
};

Tree::Tree(vector<dmatrix_row> D) { // Tree constructor from distance matrix
	cout << "Creating tree..." << endl;
	newick = ""; // Tree representation in Newick format
	int size = D.size();
	for (int i = 0; i < size; i++) {
		node new_node;
		new_node.id = i;
		new_node.isleaf = true;
		new_node.name = to_string(D[i].id + 1);
		tree.push_back(new_node);
	}
};

// Join nodes in the tree
// Each node on the tree contains its subree in Newick format

void Tree::joinNodes(int child1, int child2, float child1_distance, float child2_distance) {
	// Create parent node
	node parent;
	int parent_id = tree.size() - 1;
	parent.id = parent_id;
	parent.child1 = child1;
	parent.child2 = child2;
	parent.child1_distance = child1_distance;
	parent.child2_distance = child2_distance;
	parent.isleaf = false;
	// Update child nodes
	tree[child1].parent = parent_id;
	tree[child2].parent = parent_id;

	// Store subtree in Newick format
	if (tree[child1].isleaf) {
		parent.subtree += '(' + tree[child1].name + ":" + to_string(child1_distance) + ", ";
	}
	else {
		parent.subtree += '(' + tree[child1].subtree + ":" + to_string(child1_distance) + ", ";
	}
	if (tree[child2].isleaf) {
		parent.subtree += tree[child2].name + ":" + to_string(child2_distance) + ')';
	}
	else {
		parent.subtree += tree[child2].subtree + ":" + to_string(child2_distance) + ')';
	}

	// Store the longest string as the 
	if (parent.subtree.length() >= newick.length()) {
		newick = parent.subtree;
	}
	tree.push_back(parent);

};

//////////////////////
// Write trees to file
void write_to_file(string filename, vector<string> to_write) {
	fstream myFile;
	myFile.open(filename, ios::out | ios::trunc);
	for (size_t i = 0; i < to_write.size(); i++) {
		myFile << to_write[i] << ";" << endl;
	}
	cout << "\nNewick tree(s) saved in " << filename << endl;
	myFile.close();
}

//// WRAPPER FUNCTIONS //////

// Wraps functions to parse fasta files and output a phylogenetic tree in newick format
void fasta_to_newick(string&filename, int kmer_length, string method, string output, bool verbose) {
	vector<string> newick;
	sequence sequences = read_fasta(filename);
	vector<vector<float>> kmer_frequencies = count_kmer_frequencies(sequences, kmer_length);
	vector<dmatrix_row> D = distance_matrix(kmer_frequencies, sequences, kmer_length, method);
	Tree phylogenetic_tree(sequences);
	neighbor_joining(D, phylogenetic_tree, verbose);
	newick.push_back(phylogenetic_tree.newick);
	write_to_file(output, newick);
}

// Wraps functions to parse paml files and output a phylogenetic tree in newick format
void paml_to_newick(string& filename, int kmer_length, int n_replicates, string method, string output, bool verbose) {
	vector<string> newick_trees;
	vector<sequence> sequences = read_paml(filename, n_replicates);
	for (int i = 0; i < n_replicates; i++) {
		cout << "\nReplicate batch number " << i + 1 << "..." << endl;;
		vector<vector<float>> kmer_frequencies = count_kmer_frequencies(sequences[i], kmer_length);
		vector<dmatrix_row> D = distance_matrix(kmer_frequencies, sequences[i], kmer_length, method);
		Tree phylogenetic_tree(sequences[i]);
		neighbor_joining(D, phylogenetic_tree, verbose);
		newick_trees.push_back(phylogenetic_tree.newick);
	}
	write_to_file(output, newick_trees);
}

////////// RANDOM NEWICK TREES 
// Generate a random distance matrix of a specified size
vector<dmatrix_row> random_distance_matrix(int size) {
    vector<dmatrix_row> D (size);
    srand(time(NULL)); // Randomize seed

    for (int i = 0; i < size; i++) { // Resize vectors
        D[i].distances.resize(size);
        D[i].id = i;
    }
    
    // Fill with random numbers
    for (int i = 0; i < size; i++) {
        for (int j = i; j < size; j ++) {
            if (i != j) {
                double r = ((double) rand() / (RAND_MAX));
                D[i].distances[j] = r;
                D[j].distances[i] = r;
            }
            else {
                D[i].distances[j] = 0;
            }
        }
    }

    // Sum the rows
    for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
            D[i].sum += D[i].distances[j];
		}
	}
    return D;
}

// Wraps the functions to generate a random tree
void random_newick_tree(int size, string output, bool verbose) {
    cout << "\nGenerating a random phylogenetic tree of size " << size << " in Newick format..." << endl;
    vector<string> newick;
    vector<dmatrix_row> D = random_distance_matrix(size);
    Tree phylogenetic_tree(D);
	neighbor_joining(D, phylogenetic_tree, verbose);
	newick.push_back(phylogenetic_tree.newick);
	write_to_file(output, newick);
}

//#################################################
//#################################################
//#################################################
int main(int argc, char** argv) {
	clock_t t1, t2; t1 = clock(); //Start clock
    cout << "\nPhylogenetic tree construction in Newick format from .paml or .fasta files. Add -h as argument for additional info." << endl << endl;

	if (argc < 2) {
		help();
		return 0;
	}
    // Default parameters
    int kmer_length = 8;
    bool verbose = false;
    string method = "fractional";
    vector<string> output = {"Newick_real.txt", "Newick_synthetic.txt", "Newick_random.txt"};
    string mode, filename;
    int size;
    int n_replicates = 1;

	// Parse arguments
    string arg = string(argv[1]);
	if (arg == "-h") {help(); return 0;}   // Help
    if (arg == "-random") {                // Random distance matrix and random newick tree
        mode = "rand"; 
        size = stoi(string(argv[2])); // size of the distance matrix
    }
    else if (arg.substr(arg.length() - 6, 6) == ".fasta") { // Fasta file as argument
        mode = "real";
        filename = string(argv[1]);
    }
    else if (arg.substr(arg.length() - 5, 5) == ".paml") { // Paml file as argument
        mode = "synth";
        filename = string(argv[1]);
    }
	else {
		cout << "Wrong format.";
		return 0;
	}

	// Additional arguments
    for(int i = 0; i < argc; i++) {
        string arg (argv[i]);
        if (arg == "-k") kmer_length = stoi(string(argv[i+1])); // k-mer length
        if (arg == "-replicates") n_replicates = stoi(string(argv[i+1])); // batch size
        if (arg == "-v") verbose = true;         // Verbose output
        if (arg == "-m") method = "mahalanobis"; // Mahalanobis distance measure
        if (arg == "-c") method = "cosine";      // Cosine distance measure
		if (arg == "-h") {						 // Help
			help();
			return 0;
		}     
    }

	/////////////////
	if (mode == "real") {
		fasta_to_newick(filename, kmer_length, method, output[0], verbose);
	}

	else if (mode == "synth") {
		paml_to_newick(filename, kmer_length, n_replicates, method, output[1], verbose);
	}

    else if (mode == "rand") {
        random_newick_tree(size, output[2], verbose);
    }

	//Evaluate runtime.
	float diff((float)clock() - (float)t1);
	float seconds = diff / CLOCKS_PER_SEC;
	cout << "Time elapsed: " << seconds << "." << endl;
	return 0;
}
